#' Get data from a SQLite-database
#'
#' this function can be used to obtain data from a local or remote SQLite
#' database. If the full path with filename is provided in 'SQLiteDB', it will
#' look for that SQLite-file locally. If 'SQLiteDB' is NULL it will establish a
#' connection with a remote server. There is also functionality to use an
#' existing opened data base connection that can be provided in
#' 'use_connection'. For instance, when creating residence patches within a
#' loop of tags and tide ID's. Because establishing a conncection within a
#' for-loop takes a long time, an established connection can be used.
#' @author Pratik R. Gupte & Allert I. Bijleveld & Johannes Krietsch
#' @param tag An number representing the WATLAS tag (either in short format
#' e.g. 4 digits or long format with 11 digits). May be passed as
#' a character or a numeric, and will be converted to a character.
#' For example \code{"31001000001"}.
#' @param tracking_time_start Character representation of time from which
#' start-point data should be retrieved.
#' @param tracking_time_end Character time representing the end point
#' corresponding to the above start point.
#' @param timezone Timezone of tracking_time_start and tracking_time_end.
#'  Must be a valid timezone for the as.POSIXct function.
#' @param database The database name on the host server.
#' @param host The server address on which the data are stored.
#' @param username Username to access the server.
#' @param password Password to access the server.
#' @param SQLiteDB The full path including the filename of a local
#' SQLite-database whith tracking data. This argument overrules establishing
#' a connection with the remote host.
#' @param use_connection An R-object with a previously established connection,
#' for instance generated by \code{RMySQL::dbConnect(RMySQL::MySQL(),
#'  user = 'username', password = 'password', dbname = 'database',
#'  host = 'host')}. This argument overrules making a connection to a
#'  local host \code{SQLiteDB} or a remote host.
#' @returns A data.table of localizations of the specified tag, filtered between
#' the start and end times.\cr
#' posID	  =	Unique number for localizations \cr
#' tag		  =	4 digit tag number (character) \cr
#' time		  =	UNIX time (seconds) \cr
#' datetime = Timestamp in POSIXct (UTC) \cr
#' x		    =	x-ccordinates in meters (UTM 31 N) \cr
#' y		    =	y-ccordinates in meters (UTM 31 N) \cr
#' nbs		  =	Number of Base Stations used in calculating coordinates \cr
#' varx		  =	Variance in estimating x-coordinates \cr
#' vary		  =	Variance in estimating y-coordinates \cr
#' covxy	  =	Co-variance between y- and y-coordinates \cr
#' @import RMySQL
#' @export
#'
atl_get_data <- function(tag,
                         tracking_time_start,
                         tracking_time_end,
                         timezone = "CET",
                         database = "some_database",
                         host = "some.host.nl",
                         username = "someuser",
                         password = "somepassword",
                         SQLiteDB = NULL,
                         use_connection = NULL) {
  # global variables
  TIME <- NULL

  # check input
  assertthat::assert_that(
    any(is.numeric(tag), is.character(tag)),
    msg = "tag provided must be numeric or character"
  )
  assertthat::assert_that(
    any(nchar(as.character(tag)) < 7, nchar(as.character(tag)) == 11),
    msg = "tag should be either < 7 digits or full 11 digits"
  )
  assertthat::assert_that(
    is.character(tracking_time_start),
    msg = "start tracking time is not a character"
  )
  assertthat::assert_that(
    is.character(tracking_time_end),
    msg = "end tracking time is not a character"
  )
  assertthat::assert_that(
    is.character(timezone),
    msg = "timezone provided must be numeric or character"
  )
  db_params <- c(host, username, password)
  purrr::walk(db_params, function(this_param) {
    assertthat::assert_that(is.character(this_param),
      msg = glue::glue("{this_param} is not a character")
    )
  })

  # process parameters
  tracking_time_start <- as.POSIXct(tracking_time_start, tz = timezone)
  tracking_time_end <- as.POSIXct(tracking_time_end, tz = timezone)
  attributes(tracking_time_start)$tzone <- "UTC"
  attributes(tracking_time_end)$tzone <- "UTC"
  tracking_time_start <- as.numeric(tracking_time_start) * 1000
  tracking_time_end <- as.numeric(tracking_time_end) * 1000

  # if tag is in short format, create long format
  if (nchar(as.character(tag)) < 11) {
    tag <- atl_full_tag_id(tag)
  }

  # get data
  sql_query <- glue::glue(
    "select TAG, TIME, X, Y, NBS, VARX, VARY, COVXY\n FROM LOCALIZATIONS\n
  	WHERE TAG IN ({glue::glue_collapse(tag, sep = ',')})\n
	  AND TIME > {`tracking_time_start`}\n
  	AND TIME < {`tracking_time_end`}\n
  	ORDER BY TIME ASC"
  )

  # make new connection or use existing
  if (is.null(use_connection)) {
    # from server or file
    if (is.null(SQLiteDB)) {
      # from server database
      mydb <- RMySQL::dbConnect(RMySQL::MySQL(),
        user = username,
        password = password, dbname = database, host = host
      )
      tmp_data <- DBI::dbGetQuery(mydb, sql_query)
    } else {
      # connect to SQLite databse file
      mydb <- RSQLite::dbConnect(RSQLite::SQLite(), SQLiteDB)
      tmp_data <- RSQLite::dbGetQuery(mydb, sql_query)
    }
    RMySQL::dbDisconnect(mydb) # close connection
  } else {
    # open data with existing connection
    tmp_data <- DBI::dbGetQuery(use_connection, sql_query)
  }

  # recalculate time to seconds (instead of milliseconds)
  # and add a column with time-stamp in UTC
  if (nrow(tmp_data) > 0) {
    tmp_data <- tmp_data %>%
      dplyr::mutate(
        TIME = TIME / 1000,
        datetime = as.POSIXct(TIME,
          origin = "1970-01-01",
          tz = "UTC"
        )
      )
    tmp_data$posID <- seq.int(nrow(tmp_data))
    tmp_data$tag <- stringr::str_pad(
      as.character(substr(tmp_data$TAG, 8, 11)), 4,
      pad = "0"
    )

    # change names
    data.table::setnames(
      tmp_data,
      old = c("TIME", "X", "Y", "NBS", "VARX", "VARY", "COVXY"),
      new = c("time", "x", "y", "nbs", "varx", "vary", "covxy")
    )
    
    # transform to data.table
    setDT(tmp_data)
    
    return(tmp_data[, c(
      "posID", "tag", "time", "datetime", "x", "y",
      "nbs", "varx", "vary", "covxy"
    )])
  } else {
    warning("no data available for this tag in this time period")
    # return empty data.table with same columns
    return(tmp_data = data.table(
      posID = as.integer(),
      tag = as.character(),
      time = as.numeric(),
      datetime = as.POSIXct(NA),
      x = as.numeric(),
      y = as.numeric(),
      nbs = as.integer(),
      varx = as.numeric(),
      vary = as.numeric(),
      covxy = as.numeric()
      )
    )
  }
}
